Vấn đề N+1 query xảy ra khi client phải gọi nhiều API liên tiếp để lấy đủ dữ liệu hoàn chỉnh, dẫn đến lãng phí băng thông và hiệu suất kém. Với mô hình 3 bảng như trong sơ đồ (user, contact, role), vấn đề này trở nên nghiêm trọng hơn vì dữ liệu bị phân tán qua nhiều bảng có liên kết với nhau.
Cụ thể, khi client muốn hiển thị danh sách users kèm thông tin contact và role của họ, nếu thiết kế API không hợp lý, client sẽ phải thực hiện các bước sau: Đầu tiên gọi GET /users để lấy danh sách 10 users (giả sử). Tiếp theo, với mỗi user, client phải gọi thêm GET /contacts?user_id=X để lấy danh sách contact của user đó - tức là 10 lần nữa. Cuối cùng, client lại phải gọi GET /roles?id=Y cho mỗi user để lấy thông tin role - thêm 10 lần nữa. Như vậy tổng cộng phải thực hiện 21 API calls chỉ để hiển thị 10 users với đầy đủ thông tin.
Đây chính là vấn đề N+1: 1 query ban đầu + N queries cho contacts + N queries cho roles = 1 + N + N = 1 + 2N queries. Với 3 bảng có quan hệ, độ phức tạp tăng gấp đôi so với chỉ có 2 bảng. Điều này gây ra delay đáng kể, tốn băng thông mạng và làm giảm trải nghiệm người dùng, đặc biệt trên môi trường mạng chậm hoặc mobile.
Giải pháp là tách biệt Data Modeling và Resource Design. Ở tầng Data Modeling, chúng ta thiết kế database với 3 bảng chuẩn hóa để đảm bảo tính toàn vẹn dữ liệu. Nhưng ở tầng Resource Design (API), chúng ta cần thiết kế endpoint thông minh hơn, ví dụ: GET /users?include=contacts,role - endpoint này sẽ trả về luôn dữ liệu từ cả 3 bảng trong một lần gọi duy nhất. Backend sẽ xử lý bằng SQL JOIN hoặc eager loading để tối ưu số lượng queries xuống database.
Nếu không tách biệt hai khía cạnh này, chúng ta sẽ rơi vào tình huống: database được thiết kế tốt (chuẩn hóa, có foreign key đầy đủ) nhưng API lại thiết kế theo kiểu "một endpoint cho một bảng", khiến client phải tự ghép dữ liệu và gặp phải vấn đề N+1. Đó là lý do tại sao cần phân biệt rõ ràng giữa cách tổ chức dữ liệu trong database và cách expose dữ liệu qua API.